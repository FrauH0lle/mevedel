;;; mevedel.el --- Instructed LLM programmer/assistant -*- lexical-binding: t; -*-

;; Copyright (C) 2024-2025 daedsidog
;; Copyright (C) 2025- FrauH0lle

;; Author: FrauH0lle
;; Version: 0.5.0
;; Keywords: convenience, tools, llm, gptel, gptel-agent
;; Package-Requires: ((emacs "30.1") (gptel-agent "0.1.0"))
;; URL: https://github.com/FrauH0lle/mevedel

;; SPDX-License-Identifier: GPL-3.0-or-later
;; This program is free software; you can redistribute it and/or modify it under
;; the terms of the GNU General Public License as published by the Free Software
;; Foundation, either version 3 of the License, or (at your option) any later
;; version.
;;
;; This program is distributed in the hope that it will be useful, but WITHOUT
;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
;; FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
;; details.
;;
;; You should have received a copy of the GNU General Public License along with
;; this program.  If not, see <https://www.gnu.org/licenses/>.

;; This file is NOT part of GNU Emacs.

;;; Commentary:

;;; Code:

(require 'gptel)
(require 'gptel-agent)

(require 'mevedel-instructions)
(require 'mevedel-restorer)

;; `gptel' for @ref expansion support
(defvar gptel-prompt-transform-functions)
(declare-function gptel-mode "ext:gptel")

(defgroup mevedel nil
  "Customization group for Evedel."
  :group 'tools)

(defcustom mevedel--project-roots nil
  "List of allowed project directories for LLM access.

These directories define where the LLM is permitted to read and write
files. If empty, defaults to the current project root."
  :type '(repeat directory)
  :group 'mevedel)

(defcustom mevedel-show-patch-buffer nil
  "Control if the mevedel patch buffer should be shown automatically.

If non-nil, the patch buffer will automatically be displayed after a
query completes."
  :type 'boolean
  :group 'mevedel)

(defcustom mevedel-auto-apply-patches nil
  "Control if patches should be applied automatically.

If non-nil, patches will be applied automatically."
  :type 'boolean
  :group 'mevedel)

(defcustom mevedel-show-action-buffer t
  "Control if the mevedel action buffer should be shown automatically.

If non-nil, the action buffer will automatically be displayed."
  :type 'boolean
  :group 'mevedel)


;;
;;; Project root management

(defun mevedel--project-root ()
  "Get the primary project root directory.

Returns the first directory from `mevedel--project-roots', or falls
back to the current project root, or `default-directory'."
  (or (car mevedel--project-roots)
      (when-let ((proj (project-current)))
        (project-root proj))
      default-directory))

;;;###autoload
(defun mevedel-add-project-root (directory)
  "Add DIRECTORY to the list of allowed project roots.

This grants the LLM permission to read and write files in this
directory and its subdirectories."
  (interactive "DAdd project root: ")
  (let ((expanded (expand-file-name directory)))
    (unless (member expanded mevedel--project-roots)
      (push expanded mevedel--project-roots)
      (message "Added project root: %s" expanded))))

;;;###autoload
(defun mevedel-remove-project-root (directory)
  "Remove DIRECTORY from the list of allowed project roots."
  (interactive
   (list (if mevedel--project-roots
             (completing-read "Remove project root: " mevedel--project-roots nil t)
           (user-error "No project roots configured"))))
  (setq mevedel--project-roots (delete directory mevedel--project-roots))
  (message "Removed project root: %s" directory))

;;;###autoload
(defun mevedel-list-project-roots ()
  "Display the list of allowed project roots."
  (interactive)
  (if mevedel--project-roots
      (message "Project roots: %s"
               (mapconcat #'identity mevedel--project-roots ", "))
    (message "No project roots configured (using project root: %s)"
             (mevedel--project-root))))


;;
;;; Buffer management

(defun mevedel--action-buffer (&optional create)
  "Get or create the mevedel action (chat) buffer.

This buffer is where LLM interactions occur. If CREATE is non-nil,
create the buffer if it doesn't exist."
  (or (get-buffer "*mevedel-action*")
      (when create
        (with-current-buffer (get-buffer-create "*mevedel-action*")
          ;; Use the global gptel default mode (e.g., markdown-mode)
          (funcall (or gptel-default-mode #'text-mode))
          ;; Enable gptel-mode for a nice header and LLM interaction feedback.
          (gptel-mode +1)
          ;; Wrap lines.
          (visual-line-mode 1)
          ;; Auto-scroll when at end of buffer.
          (setq-local window-point-insertion-type t)
          (setq-local gptel--num-messages-to-send nil) ; Send all messages
          (current-buffer)))))

(defun mevedel--patch-buffer (&optional create)
  "Get or create the mevedel patch staging buffer.

This buffer shows diffs generated by the LLM that are awaiting review
and application. If CREATE is non-nil, create the buffer if it doesn't
exist."
  (or (get-buffer "*mevedel-patch*")
      (when create
        (with-current-buffer (get-buffer-create "*mevedel-patch*")
          (diff-mode)
          (setq buffer-read-only t)
          (current-buffer)))))

(defun mevedel--append-to-patch-buffer (diff filepath)
  "Append DIFF for FILEPATH to the patch buffer.

DIFF should be a unified diff string. FILEPATH is the file being
modified."
  (with-current-buffer (mevedel--patch-buffer t)
    (let ((inhibit-read-only t))
      (goto-char (point-max))
      (unless (bobp)
        (insert "\n"))
      (insert (format ";; Patch for: %s\n" filepath))
      (insert diff)
      (unless (string-suffix-p "\n" diff)
        (insert "\n"))))
  (mevedel--indicate-patch-ready))

(defun mevedel--indicate-patch-ready ()
  "Provide visual feedback that a patch is ready for review."
  (message "Patch ready in *mevedel-patch* buffer")
  (when mevedel-show-patch-buffer
    (display-buffer (mevedel--patch-buffer))))

;;;###autoload
(defun mevedel-clear-patch-buffer ()
  "Clear the patch buffer."
  (interactive)
  (when-let ((buf (mevedel--patch-buffer)))
    (with-current-buffer buf
      (let ((inhibit-read-only t))
        (erase-buffer)))
    (message "Patch buffer cleared")))


;;;###autoload
(defun mevedel-version (&optional here message)
  "Return the current version of mevedel.

Interactively, or when MESSAGE is non-nil, show it in echo area. With
prefix argument, or when HERE is non-nil, insert it at point."
  (interactive (list (or current-prefix-arg 'interactive)))
  (let ((version "v0.3.0"))
    (cond
     ((or message (called-interactively-p 'any)) (message "mevedel %s" version))
     (here (insert (format "mevedel %s" version)))
     (t version))))

(defun mevedel--implement-directive-prompt (content)
  "Generate an implementation prompt for CONTENT in the current buffer."
  (let* ((workspace-root (mevedel--project-root))
         (filename (buffer-file-name))
         (relpath
          (when filename
            (file-relative-name filename workspace-root)))
         (source-description
          (cond
           ;; No file associated with buffer.
           ((null filename)
            "")
           ;; Directory case.
           ((file-directory-p filename)
            (format "The request was sent from the workspace directory `%s`. " relpath))
           ;; Regular file case.
           (t
            (let* ((lang
                    (downcase
                     (if (stringp mode-name)
                         mode-name
                       (car mode-name)))))
              (format (concat
                       "The request was sent from the %s file `%s` in the workspace. "
                       "If the request text appears as a comment or placeholder in the file, "
                       "replace it with the actual implementation. ")
                      lang relpath))))))
    (format (concat
             "## TASK: Implement the following request using workspace tools.\n\n"
             "## INSTRUCTIONS:\n"
             "1. Read and understand the implementation request below\n"
             "2. Read and understand all provided references\n"
             "3. Use the reference to complete the request\n"
             "4. Use the workspace tools to edit files as needed\n"
             "5. Create working, complete code that fulfills the request\n\n"
             "%s"
             "\n\n##IMPLEMENTATION REQUEST:\n\n%s")
            source-description content)))

(defun mevedel--revise-directive-prompt (content &optional patch-buffer)
  "Generate a prompt for revising based on CONTENT (revision instructions).

The contents of the PATCH-BUFFER (defaulting to the mevedel patch
buffer) are included in the generated prompt."
  (let* ((patch-buffer (or patch-buffer (mevedel--patch-buffer)))
         (patch-content
          (if patch-buffer
              (with-current-buffer patch-buffer
                (buffer-substring-no-properties (point-min) (point-max)))
            ;; Doesn't make sense to call this without a patch.
            (user-error "No patch buffer found for revision"))))
    (format (concat
             "## TASK: Revise your previous implementation based on new feedback.\n\n"
             "## WHAT YOU NEED TO DO:\n"
             "1. Read the revision instructions below (if any)\n"
             "2. Review your previous patch and its original prompt\n"
             "3. Read and understand all provided references\n"
             "4. Use the reference to complete the request\n"
             "5. Understand what needs to be changed or improved\n"
             "6. Create a NEW implementation that addresses the feedback\n"
             "7. Use the workspace editing tools to make the changes\n\n"
             "%s"
             "\n\n"
             "==================================\n"
             "YOUR PREVIOUS WORK (for reference)\n"
             "==================================\n\n"
             "%s")
            (if (and content (not (string-empty-p content)))
                (format "## REVISION INSTRUCTIONS:\n%s\n\n" content)
              "")
            patch-content)))

(defun mevedel--discuss-directive-prompt (content)
  "Generate a discussion prompt for CONTENT in the current buffer."
  (let* ((workspace-root (mevedel--project-root))
         (filename (buffer-file-name))
         (relpath
          (when filename
            (file-relative-name filename workspace-root)))
         (source-description
          (cond
           ;; No file associated with buffer.
           ((null filename)
            "")
           ;; Directory case.
           ((file-directory-p filename)
            (format "The request was sent from the workspace directory `%s`. " relpath))
           ;; Regular file case.
           (t
            (let* ((lang
                    (downcase
                     (if (stringp mode-name)
                         mode-name
                       (car mode-name)))))
              (format "The request was sent from the %s file `%s` in the workspace."
                      lang relpath))))))
    (format (concat
             "## TASK: Answer the following request using workspace tools.\n\n"
             "## INSTRUCTIONS:\n"
             "1. Read and understand the implementation request below\n"
             "2. Read and understand all provided references\n"
             "3. Use the reference to complete the request\n"
             "4. Use the workspace tools to access files as needed\n"
             "%s"
             "\n\n## REQUEST:\n\n%s")
            source-description content)))


;;
;;; Commands

;;;###autoload
(defun mevedel-implement-directive (&optional callback)
  "Propose a patch to implement directive at point.

If CALLBACK is provided, it will be called when the implementation
process completes. The callback will receive three arguments: ERROR (nil
on success, a string error description on failure, or the symbol
\\='abort if the request was aborted), EXECUTION (the
macher-action-execution object for the action), and FSM (the gptel-fsm
object for the request)."
  (interactive)
  (if-let* ((directive (mevedel--topmost-instruction (mevedel--highest-priority-instruction
                                                      (mevedel--instructions-at (point) 'directive)
                                                      t)
                                                     'directive)))
      (progn
        (overlay-put directive 'mevedel-directive-action 'implement)
        (mevedel--process-directive directive 'mevedel-implement
                                    #'mevedel--implement-directive-prompt callback))
    (user-error "No directive found at point")))

;;;###autoload
(defun mevedel-revise-directive (&optional callback)
  "Propose a revision to a patch based on the directive at point.

If CALLBACK is provided, it will be called when the implementation
process completes. The callback will receive three arguments: ERROR (nil
on success, a string error description on failure, or the symbol
\\='abort if the request was aborted), EXECUTION (the
macher-action-execution object for the action), and FSM (the gptel-fsm
object for the request)."
  (interactive)
  (if-let* ((directive (mevedel--topmost-instruction (mevedel--highest-priority-instruction
                                                      (mevedel--instructions-at (point) 'directive)
                                                      t)
                                                     'directive)))
      (progn
        (overlay-put directive 'mevedel-directive-action 'revise)
        (mevedel--process-directive directive 'mevedel-revise
                                    #'mevedel--revise-directive-prompt callback))
    (user-error "No directive found at point")))

;;;###autoload
(defun mevedel-discuss-directive (&optional callback)
  "Discuss the directive at point.

If CALLBACK is provided, it will be called when the implementation
process completes. The callback will receive three arguments: ERROR (nil
on success, a string error description on failure, or the symbol
\\='abort if the request was aborted), EXECUTION (the
macher-action-execution object for the action), and FSM (the gptel-fsm
object for the request)."
  (interactive)
  (if-let* ((directive (mevedel--topmost-instruction (mevedel--highest-priority-instruction
                                                      (mevedel--instructions-at (point) 'directive)
                                                      t)
                                                     'directive)))
      (progn
        (overlay-put directive 'mevedel-directive-action 'discuss)
        (mevedel--process-directive directive 'mevedel-discuss
                                    #'mevedel--discuss-directive-prompt callback))
    (user-error "No directive found at point")))

;;;###autoload
(defun mevedel-process-directives (&optional process-all)
  "Process multiple directives sequentially while auto-applying patches.

Collects directives based on context:

- If a region is selected, collect all directives in that region
- If no region is selected but point is on a directive, collect that
  directive
- If no region and no directive at point, collect all directives in
  buffer

Presents directives to user via `completing-read-multiple' for
ordering/filtering.

Without prefix argument, only selected directives are processed in the
order chosen.

With PROCESS-ALL or prefix argument (\\[universal-argument]), all
directives are processed: selected directives are processed first in the
chosen order, followed by unselected directives in their original order.

Temporarily enables `mevedel-auto-apply-patches' during processing."
  (interactive "P")
  (let (found-directives)
    ;; Collect directives based on context
    (cond ((region-active-p)
           (when-let* ((toplevel-directives
                        (cl-remove-duplicates
                         (mapcar (lambda (instr)
                                   (mevedel--topmost-instruction instr 'directive))
                                 (mevedel--instructions-in (region-beginning)
                                                           (region-end)
                                                           'directive)))))
             (setq found-directives toplevel-directives)))
          (t
           (if-let* ((directive (mevedel--topmost-instruction (mevedel--highest-priority-instruction
                                                               (mevedel--instructions-at (point) 'directive)
                                                               t)
                                                              'directive)))
               (setq found-directives (list directive))
             (when-let* ((toplevel-directives (cl-remove-duplicates
                                               (mapcar (lambda (instr)
                                                         (mevedel--topmost-instruction instr 'directive))
                                                       (without-restriction
                                                         (mevedel--instructions-in (point-min)
                                                                                   (point-max)
                                                                                   'directive))))))
               (setq found-directives toplevel-directives)))))

    (if (null found-directives)
        (user-error "No directives found")
      ;; Create display strings and mapping for completing-read-multiple
      (let* ((ov-strings (cl-loop for ov in found-directives
                                  collect (format "#%d: %s"
                                                  (overlay-get ov 'mevedel-id)
                                                  (mevedel--directive-text ov))))
             (ov-map (cl-loop for str in ov-strings
                              for ov in found-directives
                              collect (cons str ov)))
             ;; Let user select and order directives
             (prompt (if process-all
                         "Order directives to process first (unselected will follow, leave empty for all): "
                       "Select directives to process (in order, leave empty for all): "))
             (selected-strings (cl-remove-duplicates
                                (or (completing-read-multiple prompt ov-strings)
                                    ov-strings)
                                :test #'equal))
             ;; Build final directive list based on mode
             (selected-directives (mapcar (lambda (str) (cdr (assoc str ov-map)))
                                          selected-strings))
             (directives-to-process
              (if process-all
                  ;; Process-all mode: selected first, then unselected
                  (let ((unselected-directives (cl-remove-if (lambda (ov)
                                                               (memq ov selected-directives))
                                                             found-directives)))
                    (append selected-directives unselected-directives))
                ;; Default mode: only process selected directives
                selected-directives))
             (total-count (length directives-to-process))
             (original-auto-apply mevedel-auto-apply-patches))

        (if (zerop total-count)
            (message "No directives to process")
          ;; Process directives sequentially
          (message "Processing %d directive%s..." total-count (if (= total-count 1) "" "s"))
          (mevedel--process-directives-sequentially directives-to-process 1 total-count original-auto-apply))))))

(defun mevedel--process-directives-sequentially (directives current total original-auto-apply)
  "Process DIRECTIVES sequentially, showing progress.

CURRENT is the current directive number (1-indexed).
TOTAL is the total number of directives.
ORIGINAL-AUTO-APPLY is the original value of `mevedel-auto-apply-patches'."
  (if (null directives)
      ;; All done - restore original setting
      (progn
        (setq mevedel-auto-apply-patches original-auto-apply)
        (message "Completed processing %d directive%s" total (if (= total 1) "" "s")))
    ;; Process next directive
    (let ((directive (car directives))
          (remaining (cdr directives)))
      ;; Enable auto-apply for this batch
      (setq mevedel-auto-apply-patches t)
      (message "Processing directive %d/%d: #%d %s"
               current total
               (overlay-get directive 'mevedel-id)
               (mevedel--directive-text directive))
      ;; Set up callback to process next directive
      (let ((callback (lambda (err _execution _fsm)
                        (if err
                            (progn
                              ;; Restore original setting and stop processing
                              (setq mevedel-auto-apply-patches original-auto-apply)
                              (message "Stopped processing at directive %d/%d due to error: %s"
                                       current total err))
                          ;; Success - continue with next directive
                          (mevedel--process-directives-sequentially
                           remaining (1+ current) total original-auto-apply)))))
        (overlay-put directive 'mevedel-directive-action 'implement)
        (mevedel--process-directive directive 'mevedel-implement
                                    #'mevedel--implement-directive-prompt callback)))))

(defvar mevedel--current-directive-uuid nil
  "UUID of the directive currently being processed.")

(defun mevedel--process-directive (directive preset prompt-fn callback)
  "Process DIRECTIVE using PRESET and PROMPT-FN, calling CALLBACK when complete.

DIRECTIVE is the instruction overlay to process.
PRESET is the gptel preset to use (mevedel-implement, mevedel-revise, mevedel-discuss).
PROMPT-FN is a function that generates the prompt from the directive content.
CALLBACK is called with (err execution fsm) when processing completes.

Updates directive status and overlay, handles success/failure states."
  ;; Save any unsaved buffers first
  (save-some-buffers nil (lambda () (and (buffer-file-name) (buffer-modified-p))))

  (let* ((content (mevedel--directive-llm-prompt directive))
         (prompt (funcall prompt-fn content))
         (action-buffer (mevedel--action-buffer t))
         (callback-fn (lambda (err execution fsm)
                        (if err
                            (let ((reason (if (eq err 'abort) "aborted" (format "%s" err))))
                              (overlay-put directive 'mevedel-directive-status 'failed)
                              (overlay-put directive 'mevedel-directive-fail-reason reason)
                              (mevedel--update-instruction-overlay directive t)
                              (pulse-momentary-highlight-region (overlay-start directive) (overlay-end directive))
                              (setq mevedel--current-directive-uuid nil)
                              (when callback
                                (funcall callback err execution fsm)))
                          (overlay-put directive 'mevedel-directive-status 'succeeded)
                          (with-current-buffer (overlay-buffer directive)
                            ;; Delete any child directives of the top-level directive
                            (let ((child-directives (cl-remove-if-not #'mevedel--directivep
                                                                      (mevedel--child-instructions directive))))
                              (dolist (child-directive child-directives)
                                (mevedel--delete-instruction child-directive)))
                            (save-excursion
                              (goto-char (overlay-start directive))
                              (overlay-put directive 'evaporate t)))
                          (mevedel--update-instruction-overlay directive t)
                          (pulse-momentary-highlight-region (overlay-start directive) (overlay-end directive))
                          (setq mevedel--current-directive-uuid nil)
                          (when callback
                            (funcall callback err execution fsm))))))

    (setq mevedel--current-directive-uuid (overlay-get directive 'mevedel-uuid))

    ;; Add current directive to history
    (with-current-buffer (overlay-buffer directive)
      (let ((entry (mevedel--create-history-entry directive))
            (current-history-pos (overlay-get directive 'mevedel-directive-history-position)))
        (if (or (not current-history-pos) (= current-history-pos 0))
            ;; Add entry to the front
            (push entry (overlay-get directive 'mevedel-directive-history))
          ;; Cut off anything before current position and add current entry
          (let ((history (overlay-get directive 'mevedel-directive-history)))
            (setf (overlay-get directive 'mevedel-directive-history)
                  (cons entry (nthcdr (1+ current-history-pos) history)))))
        ;; Reset history position when new entry is added
        (overlay-put directive 'mevedel-directive-history-position 0)))

    (overlay-put directive 'mevedel-directive-status 'processing)
    (mevedel--update-instruction-overlay directive t)
    (pulse-momentary-highlight-region (overlay-start directive) (overlay-end directive))

    ;; Display action buffer if configured
    (when mevedel-show-action-buffer
      (display-buffer action-buffer))

    ;; Execute with gptel-request
    (with-current-buffer action-buffer
      (goto-char (point-max))
      (insert "\n\n" prompt "\n\n")
      (gptel-with-preset preset
        (gptel-request nil ;; prompt
          :buffer action-buffer
          :position (point-max)
          :callback (lambda (resp info)
                      (mevedel--intercept-tool-results resp info)
                      ;; Call user callback
                      ;; Note: We don't have execution/fsm objects anymore, pass nil
                      (funcall callback-fn nil nil nil)))))))

;;;###autoload
(defun mevedel-instruction-count ()
  "Return the number of instructions currently loaded instructions.

If called interactively, it messages the number of instructions and
buffers."
  (interactive)
  (let ((count 0)
        (buffer-hash (make-hash-table :test 'eq)))
    (mevedel--foreach-instruction instr count instr into instr-count
                                  do (puthash (overlay-buffer instr) t buffer-hash)
                                  finally (setf count instr-count))
    (let ((buffers (hash-table-count buffer-hash)))
      (when (called-interactively-p 'interactive)
        (if (= count 0)
            (message "No macher instructions currently loaded")
          (message "macher is showing %d instruction%s from %d buffer%s"
                   count (if (/= count 1) "s" "")
                   buffers (if (/= buffers 1) "s" ""))))
      count)))

;;;###autoload
(defun mevedel-create-reference ()
  "Create a reference instruction within the selected region.

If a region is selected but partially covers an existing reference, then
the command will resize the reference in the following manner:

  - If the mark is located INSIDE the reference (i.e., the point is
    located OUTSIDE the reference) then the reference will be expanded
    to the point.
  - If the mark is located OUTSIDE the reference (i.e., the point is
    located INSIDE the reference) then the reference will be shrunk to
    the point."
  (interactive)
  (mevedel--create-instruction 'reference))

;;;###autoload
(defun mevedel-create-directive ()
  "Create a directive instruction within the selected region.

If a region is selected but partially covers an existing directive, then
the command will resize the directive in the following manner:

  - If the mark is located INSIDE the directive (i.e., the point is
    located OUTSIDE the directive) then the directive will be expanded
    to the point.
  - If the mark is located OUTSIDE the directive (i.e., the point is
    located INSIDE the directive) then the directive will be shrunk to
    the point."
  (interactive)
  (mevedel--create-instruction 'directive))


;;
;;; Custom tools

(defun mevedel--define-tools ()
  "Define custom mevedel tools for gptel-agent."
  (require 'gptel)
  (require 'gptel-agent)

  ;; Tool for LLM to ask user questions during execution
  (gptel-make-tool
   :name "ask_user"
   :function (lambda (callback question &optional options)
               "Ask the user a question and wait for response.

CALLBACK is automatically prepended for async tools.
QUESTION is the question string to ask the user.
OPTIONS is an optional array of predefined choices."
               (let ((answer (if options
                                 (let ((choice (completing-read
                                                (concat question " ")
                                                (append options '("Other"))
                                                nil nil)))
                                   (if (equal choice "Other")
                                       (read-string (concat question " (custom): "))
                                     choice))
                               (read-string (concat question " ")))))
                 (funcall callback answer)))
   :description "Ask the user a question and wait for their response. Use this when you need clarification or user input to proceed with a task."
   :args '((:name "question"
            :type string
            :description "The question to ask the user")
           (:name "options"
            :type array
            :items (:type string)
            :optional t
            :description "Optional list of predefined choices for the user to select from"))
   :async t
   :confirm nil  ;; Already interactive
   :include t
   :category "mevedel")

  ;; Tool for LLM to request access to new directories
  (gptel-make-tool
   :name "request_directory_access"
   :function (lambda (callback directory reason)
               "Request user permission to access a directory.

CALLBACK is for async execution.
DIRECTORY is the path to request access to.
REASON explains why access is needed."
               (let ((expanded (expand-file-name directory)))
                 (if (yes-or-no-p
                      (format "Grant LLM access to directory: %s\n\nReason: %s\n\nAllow access? "
                              expanded reason))
                     (progn
                       (mevedel-add-project-root expanded)
                       (funcall callback
                                (format "Access granted to %s. You can now read and write files in this directory." expanded)))
                   (funcall callback
                            (format "Access denied to %s. You cannot access files in this directory." expanded)))))
   :description "Request access to a directory outside the current allowed project roots. You must explain why you need access to this directory."
   :args '((:name "directory"
            :type string
            :description "Absolute or relative path to the directory you need to access")
           (:name "reason"
            :type string
            :description "Clear explanation of why you need access to this directory and what you plan to do there"))
   :async t
   :confirm nil  ;; Confirmation handled within the tool
   :include t
   :category "mevedel"))


;;
;;; Tool result interception

(defun mevedel--intercept-tool-results (resp info)
  "Intercept tool results from gptel-agent to capture patches.

This callback function is used with `gptel-request' to monitor tool
execution. When `edit_files' is executed, the diff is extracted and
added to the patch buffer.

RESP is the response from the LLM, which can be:
- A string (normal text response)
- `(tool-result . RESULTS)' (after tool execution)
- `(tool-call . PENDING)' (awaiting confirmation)
- `abort' (request aborted)
- nil (error)

INFO is the request info plist containing tool execution details."
  (pcase resp
    (`(tool-result . ,results)
     ;; Tool execution completed, check for edit_files and handle separately
     (dolist (tool-result results)
       (cl-destructuring-bind (tool-spec args result) tool-result
         (when (equal (gptel-tool-name tool-spec) "edit_files")
           ;; Extract the diff that was applied
           (when-let* ((diff (plist-get args :new_str))
                       (path (plist-get args :path)))
             (mevedel--append-to-patch-buffer diff path)
             ;; Auto-apply if configured
             (when mevedel-auto-apply-patches
               (mevedel-diff-apply-buffer))))))
     ;; Display all tool results normally (gptel handles edit_files display internally)
     (gptel--display-tool-results results info))
    (`(reasoning . ,text)
     (gptel--display-reasoning-stream text info))
    (`(tool-call . ,tool-calls)
     (gptel--display-tool-calls tool-calls info))

    ;; (`(tool-call . ,_pending-calls)
    ;;  ;; Tool confirmation pending
    ;;  (message "Tool call awaiting confirmation..."))

    ((pred stringp)
     ;; Normal text response - insert into action buffer if it exists
     (when-let ((buf (mevedel--action-buffer)))
       (with-current-buffer buf
         (save-excursion
           (goto-char (point-max))
           (unless (bobp)
             (insert "\n"))
           (insert resp)))))

    ('abort
     (message "Request aborted"))

    ('nil
     (message "Request error"))

    (_
     (message "Unknown response type: %S" resp))))


;;
;;; Presets

(defun mevedel--define-presets ()
  "Define gptel presets for mevedel actions."
  (require 'gptel)

  ;; Read-only preset for discussion/analysis
  (gptel-make-preset 'mevedel-discuss
    :description "Read-only tools for code analysis and discussion"
    :tools '(:eval
             (cl-remove-if
              (lambda (name)
                (member name '("edit_files" "write_file" "insert_in_file")))
              (mapcar #'gptel-tool-name
                      (gptel-get-tool "gptel-agent"))))
    :system "You are helping analyze and discuss code. Use read_file_lines and grep_files to understand the codebase. Do not make any file modifications.")

  ;; Full editing preset for implementation
  (gptel-make-preset 'mevedel-implement
    :parents '(mevedel-discuss)
    :description "Full editing capabilities with patch review workflow"
    :tools '("gptel-agent")
    :system "You are implementing code changes using workspace tools. Use edit_files to make changes. All changes will be staged in a patch buffer for user review before applying.")

  ;; Revision preset with previous patch context
  (gptel-make-preset 'mevedel-revise
    :parents '(mevedel-implement)
    :description "Revise previous implementation with full context"
    :system "You are revising a previous implementation. The previous patch and its context are included in the conversation. Analyze what needs to be changed and create an improved implementation."))


;;
;;; Installation

;;;###autoload
(defun mevedel-install ()
  "Register `mevedel' presets, tools, and hooks."
  (interactive)

  ;; Define gptel presets
  (mevedel--define-presets)

  ;; Define custom tools
  (mevedel--define-tools)

  ;; Add @ref expansion to gptel transform functions
  (add-hook 'gptel-prompt-transform-functions #'mevedel--transform-expand-refs -90)

  ;; Setup font-lock and completion for @ref mentions in gptel buffers
  (add-hook 'gptel-mode-hook #'mevedel--prettify-ref-mentions)

  (message "mevedel installed successfully"))

;;;###autoload
(defun mevedel-uninstall ()
  "Remove `mevedel' hooks and cleanup."
  (interactive)
  ;; Remove @ref expansion from gptel
  (remove-hook 'gptel-prompt-transform-functions #'mevedel--transform-expand-refs)

  ;; Remove font-lock and completion setup
  (remove-hook 'gptel-mode-hook #'mevedel--prettify-ref-mentions))

(provide 'mevedel)

;;; mevedel.el ends here.
