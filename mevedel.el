;;; mevedel.el --- Instructed LLM programmer/assistant -*- lexical-binding: t; -*-

;; Copyright (C) 2024-2025 daedsidog
;; Copyright (C) 2025- FrauH0lle

;; Author: FrauH0lle
;; Version: 0.5.0
;; Keywords: convenience, tools, llm, gptel, gptel-agent
;; Package-Requires: ((emacs "30.1") (gptel-agent "0.0.1"))
;; URL: https://github.com/FrauH0lle/mevedel

;; SPDX-License-Identifier: GPL-3.0-or-later
;; This program is free software; you can redistribute it and/or modify it under
;; the terms of the GNU General Public License as published by the Free Software
;; Foundation, either version 3 of the License, or (at your option) any later
;; version.
;;
;; This program is distributed in the hope that it will be useful, but WITHOUT
;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
;; FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
;; details.
;;
;; You should have received a copy of the GNU General Public License along with
;; this program.  If not, see <https://www.gnu.org/licenses/>.

;; This file is NOT part of GNU Emacs.

;;; Commentary:

;;; Code:

(require 'gptel)
(require 'gptel-agent)

(require 'mevedel-workspace)
(require 'mevedel-instructions)
(require 'mevedel-restorer)
(require 'mevedel-agents)
(provide 'mevedel-presets)
(require 'mevedel-tools)
(require 'mevedel-system)

;; `gptel'
(defvar gptel-prompt-transform-functions)
(declare-function gptel-mode "ext:gptel")


(defgroup mevedel nil
  "Customization group for Evedel."
  :group 'tools)

(defcustom mevedel-show-patch-buffer nil
  "Control if the mevedel patch buffer should be shown automatically.

If non-nil, the patch buffer will automatically be displayed after a
query completes."
  :type 'boolean
  :group 'mevedel)

(defvar mevedel--diff-preview-buffer-name "*mevedel-diff-preview*"
  "Name of the `diff' preview buffer.")

(defcustom mevedel-auto-apply-patches nil
  "Control if patches should be applied automatically.

If non-nil, patches will be applied automatically."
  :type 'boolean
  :group 'mevedel)

(defcustom mevedel-show-chat-buffer t
  "Control if the mevedel chat buffer should be shown automatically.

If non-nil, the chat buffer will automatically be displayed."
  :type 'boolean
  :group 'mevedel)

(defcustom mevedel-plans-directory
  (expand-file-name (file-name-concat "mevedel" "plans") temporary-file-directory)
  "Directory where implementation plans are stored.

Defaults to a temporary directory. Set this to a permanent location
if you want to keep plans persistently."
  :type 'directory
  :group 'mevedel)


;;
;;; Buffer management

(defun mevedel--chat-buffer (&optional create workspace)
  "Get or create the mevedel chat buffer for WORKSPACE.

This buffer is where LLM interactions occur. If CREATE is non-nil,
create the buffer if it doesn't exist. WORKSPACE should be a cons cell
\(TYPE . ID), or nil to use the current buffer's workspace."
  (let* ((workspace (or workspace (mevedel-workspace)))
         (buf (mevedel--get-buffer nil workspace create))
         (created-p (cdr buf))
         (buf (car buf)))
    (when created-p
      (with-current-buffer buf
        ;; NOTE 2025-11-04: For now, only support `org-mode'
        ;; Use the global gptel default mode (e.g., markdown-mode)
        ;; (funcall (or gptel-default-mode #'text-mode))
        (org-mode)
        ;; Enable `gptel-mode'
        (gptel-mode +1)
        ;; Wrap lines
        (visual-line-mode +1)
        ;; Auto-scroll when at end of buffer
        (setq-local window-point-insertion-type t)
        ;; Set `default-directory' to workspace root
        (setq-local default-directory (mevedel-workspace--root workspace))
        ;; Make workspace-additional-roots buffer-local for session-specific access grants
        ;; Start with a copy of the global value so pre-configured roots are available
        (setq-local mevedel-workspace-additional-roots
                    (copy-alist mevedel-workspace-additional-roots))
        (add-hook 'gptel-post-response-functions #'mevedel--clear-pending-access-requests nil t)))
    buf))

(defun mevedel--patch-buffer (&optional create workspace)
  "Get or create the mevedel patch staging buffer for WORKSPACE.

This buffer shows diffs generated by the LLM that are awaiting review
and application. If CREATE is non-nil, create the buffer if it doesn't
exist. WORKSPACE should be a cons cell (TYPE . ID), or nil to use the
current buffer's workspace."
  (let* ((buf (mevedel--get-buffer "patch" workspace create))
         (created-p (cdr buf))
         (buf (car buf)))
    (when created-p
      (with-current-buffer buf
        (diff-mode)
        (setq buffer-read-only t)))
    buf))

(defun mevedel--get-buffer (&optional buffer-suffix workspace create-p)
  "Get or create a buffer for WORKSPACE with optional BUFFER-SUFFIX.

Returns (BUFFER . CREATED-P) where CREATED-P indicates if buffer was
created. When CREATE-P is non-nil and buffer doesn't exist, create it
with workspace."
  (let* ((workspace (or workspace (mevedel-workspace)))
         (workspace-type (car workspace))
         (workspace-name (mevedel-workspace--name workspace))
         (buf-name (format "*mevedel%s:%s@%s*"
                           (if buffer-suffix (format "-%s" buffer-suffix) "")
                           workspace-type
                           workspace-name))
         (target-buf (and buf-name (get-buffer buf-name)))
         created-p)
    (when (and (not target-buf) create-p buf-name)
      (setq target-buf (get-buffer-create buf-name)
            created-p t)
      (with-current-buffer target-buf
        ;; Set workspace for this buffer
        (setq-local mevedel--workspace workspace)))
    (when target-buf
      (cons target-buf created-p))))

(defun mevedel--generate-final-patch ()
  "Generate final diffs for all tracked files in current request.
Returns a unified diff string showing original â†’ final state for each file.
Uses the `mevedel--request-file-snapshots' to compare original states with
current file contents."
  (let ((diffs "")
        (workspace-root (mevedel-workspace--root (mevedel-workspace))))
    (dolist (snapshot mevedel--request-file-snapshots)
      (let* ((filepath (car snapshot))
             (original (cdr snapshot))
             (current (when (file-exists-p filepath)
                        (with-temp-buffer
                          (insert-file-contents filepath)
                          (buffer-string))))
             (relpath (file-relative-name filepath workspace-root)))

        ;; Generate diff if file changed, was deleted, or was created
        (when (or
               ;; Modified
               (and original current (not (string= original current)))
               ;; Deleted
               (and original (not current))
               ;; Created
               (and (not original) current))
          (setq diffs (concat diffs
                              (format "diff --git a/%s b/%s\n" relpath relpath)
                              (mevedel-tools--generate-diff
                               (or original "")
                               (or current "")
                               relpath)
                              "\n")))))
    diffs))

(defun mevedel--replace-patch-buffer (patch-content)
  "Replace patch buffer contents with PATCH-CONTENT.
If PATCH-CONTENT is empty, does nothing."
  (when (and patch-content (> (length patch-content) 0))
    (with-current-buffer (mevedel--patch-buffer t)
      (let ((inhibit-read-only t))
        (erase-buffer)
        (insert patch-content)
        (diff-mode)
        (goto-char (point-min))))
    (mevedel--indicate-patch-ready)))

(defun mevedel--indicate-patch-ready ()
  "Provide visual feedback that a patch is ready for review."
  (message "Patch ready in *mevedel-patch* buffer")
  (when mevedel-show-patch-buffer
    (display-buffer (mevedel--patch-buffer))))

;;;###autoload
(defun mevedel-clear-patch-buffer ()
  "Clear the patch buffer."
  (interactive)
  (when-let ((buf (mevedel--patch-buffer)))
    (with-current-buffer buf
      (let ((inhibit-read-only t))
        (erase-buffer)))
    (message "Patch buffer cleared")))


;;;###autoload
(defun mevedel-version (&optional here message)
  "Return the current version of mevedel.

Interactively, or when MESSAGE is non-nil, show it in echo area. With
prefix argument, or when HERE is non-nil, insert it at point."
  (interactive (list (or current-prefix-arg 'interactive)))
  (let ((version "v0.5.0"))
    (cond
     ((or message (called-interactively-p 'any)) (message "mevedel %s" version))
     (here (insert (format "mevedel %s" version)))
     (t version))))

(defun mevedel--implement-directive-prompt (content)
  "Generate an implementation prompt for CONTENT in the current buffer."
  (let* ((workspace-root (mevedel-workspace--root (mevedel-workspace)))
         (filename (buffer-file-name))
         (relpath
          (when filename
            (file-relative-name filename workspace-root)))
         (source-description
          (cond
           ;; No file associated with buffer.
           ((null filename)
            "")
           ;; Directory case.
           ((file-directory-p filename)
            (format "The request was sent from the workspace directory `%s`. " relpath))
           ;; Regular file case.
           (t
            (let* ((lang
                    (downcase
                     (if (stringp mode-name)
                         mode-name
                       (car mode-name)))))
              (format (concat
                       "The request was sent from the %s file `%s` in the workspace. "
                       "If the request text appears as a comment or placeholder in the file, "
                       "replace it with the actual implementation. ")
                      lang relpath))))))
    (format (concat
             "## TASK: Implement the following request using workspace tools.\n\n"
             "## INSTRUCTIONS:\n"
             "1. Read and understand the implementation request below\n"
             "2. Read and understand all provided references\n"
             "3. Use the reference to complete the request\n"
             "4. Use the workspace tools to edit files as needed\n"
             "5. Create working, complete code that fulfills the request\n\n"
             "%s"
             "\n\n##IMPLEMENTATION REQUEST:\n\n%s")
            source-description content)))

(defun mevedel--revise-directive-prompt (content &optional patch-buffer)
  "Generate a prompt for revising based on CONTENT (revision instructions).

The contents of the PATCH-BUFFER (defaulting to the mevedel patch
buffer) are included in the generated prompt."
  (let* ((patch-buffer (or patch-buffer (mevedel--patch-buffer)))
         (patch-content
          (if patch-buffer
              (with-current-buffer patch-buffer
                (buffer-substring-no-properties (point-min) (point-max)))
            ;; Doesn't make sense to call this without a patch.
            (user-error "No patch buffer found for revision"))))
    (format (concat
             "## TASK: Revise your previous implementation based on new feedback.\n\n"
             "## WHAT YOU NEED TO DO:\n"
             "1. Read the revision instructions below (if any)\n"
             "2. Review your previous patch and its original prompt\n"
             "3. Read and understand all provided references\n"
             "4. Use the reference to complete the request\n"
             "5. Understand what needs to be changed or improved\n"
             "6. Create a NEW implementation that addresses the feedback\n"
             "7. Use the workspace editing tools to make the changes\n\n"
             "%s"
             "\n\n"
             "==================================\n"
             "YOUR PREVIOUS WORK (for reference)\n"
             "==================================\n\n"
             "%s")
            (if (and content (not (string-empty-p content)))
                (format "## REVISION INSTRUCTIONS:\n%s\n\n" content)
              "")
            patch-content)))

(defun mevedel--discuss-directive-prompt (content)
  "Generate a discussion prompt for CONTENT in the current buffer."
  (let* ((workspace-root (mevedel-workspace--root (mevedel-workspace)))
         (filename (buffer-file-name))
         (relpath
          (when filename
            (file-relative-name filename workspace-root)))
         (source-description
          (cond
           ;; No file associated with buffer.
           ((null filename)
            "")
           ;; Directory case.
           ((file-directory-p filename)
            (format "The request was sent from the workspace directory `%s`. " relpath))
           ;; Regular file case.
           (t
            (let* ((lang
                    (downcase
                     (if (stringp mode-name)
                         mode-name
                       (car mode-name)))))
              (format "The request was sent from the %s file `%s` in the workspace."
                      lang relpath))))))
    (format (concat
             "## TASK: Answer the following request using workspace tools.\n\n"
             "## INSTRUCTIONS:\n"
             "1. Read and understand the implementation request below\n"
             "2. Read and understand all provided references\n"
             "3. Use the reference to complete the request\n"
             "4. Use the workspace tools to access files as needed\n"
             "%s"
             "\n\n## REQUEST:\n\n%s")
            source-description content)))


;;
;;; Commands

;;;###autoload
(defun mevedel-implement-directive (&optional callback)
  "Propose a patch to implement directive at point.

If CALLBACK is provided, it will be called when the implementation
process completes. The callback will receive three arguments: ERROR (nil
on success, a string error description on failure, or the symbol
\\='abort if the request was aborted), EXECUTION (the
macher-action-execution object for the action), and FSM (the gptel-fsm
object for the request)."
  (interactive)
  (if-let* ((directive (mevedel--topmost-instruction (mevedel--highest-priority-instruction
                                                      (mevedel--instructions-at (point) 'directive)
                                                      t)
                                                     'directive)))
      (progn
        (overlay-put directive 'mevedel-directive-action 'implement)
        (mevedel--process-directive directive (alist-get 'implement mevedel-action-preset-alist)
                                    #'mevedel--implement-directive-prompt callback))
    (user-error "No directive found at point")))

;;;###autoload
(defun mevedel-revise-directive (&optional callback)
  "Propose a revision to a patch based on the directive at point.

If CALLBACK is provided, it will be called when the implementation
process completes. The callback will receive three arguments: ERROR (nil
on success, a string error description on failure, or the symbol
\\='abort if the request was aborted), EXECUTION (the
macher-action-execution object for the action), and FSM (the gptel-fsm
object for the request)."
  (interactive)
  (if-let* ((directive (mevedel--topmost-instruction (mevedel--highest-priority-instruction
                                                      (mevedel--instructions-at (point) 'directive)
                                                      t)
                                                     'directive)))
      (progn
        (overlay-put directive 'mevedel-directive-action 'revise)
        (mevedel--process-directive directive (alist-get 'revise mevedel-action-preset-alist)
                                    #'mevedel--revise-directive-prompt callback))
    (user-error "No directive found at point")))

;;;###autoload
(defun mevedel-discuss-directive (&optional callback)
  "Discuss the directive at point.

If CALLBACK is provided, it will be called when the implementation
process completes. The callback will receive three arguments: ERROR (nil
on success, a string error description on failure, or the symbol
\\='abort if the request was aborted), EXECUTION (the
macher-action-execution object for the action), and FSM (the gptel-fsm
object for the request)."
  (interactive)
  (if-let* ((directive (mevedel--topmost-instruction (mevedel--highest-priority-instruction
                                                      (mevedel--instructions-at (point) 'directive)
                                                      t)
                                                     'directive)))
      (progn
        (overlay-put directive 'mevedel-directive-action 'discuss)
        (mevedel--process-directive directive (alist-get 'discuss mevedel-action-preset-alist)
                                    #'mevedel--discuss-directive-prompt callback))
    (user-error "No directive found at point")))

;;;###autoload
(defun mevedel-teach-directive (&optional callback)
  "Guide user to solve directive through hints (no solutions).

If CALLBACK is provided, it will be called when the teaching
process completes.  The callback will receive three arguments: ERROR (nil
on success, a string error description on failure, or the symbol
\\='abort if the request was aborted), EXECUTION (the
macher-action-execution object for the action), and FSM (the gptel-fsm
object for the request)."
  (interactive)
  (if-let* ((directive (mevedel--topmost-instruction (mevedel--highest-priority-instruction
                                                      (mevedel--instructions-at (point) 'directive)
                                                      t)
                                                     'directive)))
      (progn
        (overlay-put directive 'mevedel-directive-action 'teach)
        (mevedel--process-directive directive (alist-get 'teach mevedel-action-preset-alist)
                                    #'mevedel--discuss-directive-prompt callback))
    (user-error "No directive found at point")))

;;;###autoload
(defun mevedel-process-directives (&optional process-all)
  "Process multiple directives sequentially while auto-applying patches.

Collects directives based on context:

- If a region is selected, collect all directives in that region
- If no region is selected but point is on a directive, collect that
  directive
- If no region and no directive at point, collect all directives in
  buffer

Presents directives to user via `completing-read-multiple' for
ordering/filtering.

Without prefix argument, only selected directives are processed in the
order chosen.

With PROCESS-ALL or prefix argument (\\[universal-argument]), all
directives are processed: selected directives are processed first in the
chosen order, followed by unselected directives in their original order.

Temporarily enables `mevedel-auto-apply-patches' during processing."
  (interactive "P")
  (let (found-directives)
    ;; Collect directives based on context
    (cond ((region-active-p)
           (when-let* ((toplevel-directives
                        (cl-remove-duplicates
                         (mapcar (lambda (instr)
                                   (mevedel--topmost-instruction instr 'directive))
                                 (mevedel--instructions-in (region-beginning)
                                                           (region-end)
                                                           'directive)))))
             (setq found-directives toplevel-directives)))
          (t
           (if-let* ((directive (mevedel--topmost-instruction (mevedel--highest-priority-instruction
                                                               (mevedel--instructions-at (point) 'directive)
                                                               t)
                                                              'directive)))
               (setq found-directives (list directive))
             (when-let* ((toplevel-directives (cl-remove-duplicates
                                               (mapcar (lambda (instr)
                                                         (mevedel--topmost-instruction instr 'directive))
                                                       (without-restriction
                                                         (mevedel--instructions-in (point-min)
                                                                                   (point-max)
                                                                                   'directive))))))
               (setq found-directives toplevel-directives)))))

    (if (null found-directives)
        (user-error "No directives found")
      ;; Create display strings and mapping for completing-read-multiple
      (let* ((ov-strings (cl-loop for ov in found-directives
                                  collect (format "#%d: %s"
                                                  (overlay-get ov 'mevedel-id)
                                                  (mevedel--directive-text ov))))
             (ov-map (cl-loop for str in ov-strings
                              for ov in found-directives
                              collect (cons str ov)))
             ;; Let user select and order directives
             (prompt (if process-all
                         "Order directives to process first (unselected will follow, leave empty for all): "
                       "Select directives to process (in order, leave empty for all): "))
             (selected-strings (cl-remove-duplicates
                                (or (completing-read-multiple prompt ov-strings)
                                    ov-strings)
                                :test #'equal))
             ;; Build final directive list based on mode
             (selected-directives (mapcar (lambda (str) (cdr (assoc str ov-map)))
                                          selected-strings))
             (directives-to-process
              (if process-all
                  ;; Process-all mode: selected first, then unselected
                  (let ((unselected-directives (cl-remove-if (lambda (ov)
                                                               (memq ov selected-directives))
                                                             found-directives)))
                    (append selected-directives unselected-directives))
                ;; Default mode: only process selected directives
                selected-directives))
             (total-count (length directives-to-process))
             (original-auto-apply mevedel-auto-apply-patches))

        (if (zerop total-count)
            (message "No directives to process")
          ;; Process directives sequentially
          (message "Processing %d directive%s..." total-count (if (= total-count 1) "" "s"))
          (mevedel--process-directives-sequentially directives-to-process 1 total-count original-auto-apply))))))

(defun mevedel--process-directives-sequentially (directives current total original-auto-apply)
  "Process DIRECTIVES sequentially, showing progress.

CURRENT is the current directive number (1-indexed).
TOTAL is the total number of directives.
ORIGINAL-AUTO-APPLY is the original value of `mevedel-auto-apply-patches'."
  (if (null directives)
      ;; All done - restore original setting
      (progn
        (setq mevedel-auto-apply-patches original-auto-apply)
        (message "Completed processing %d directive%s" total (if (= total 1) "" "s")))
    ;; Process next directive
    (let ((directive (car directives))
          (remaining (cdr directives)))
      ;; Enable auto-apply for this batch
      (setq mevedel-auto-apply-patches t)
      (message "Processing directive %d/%d: #%d %s"
               current total
               (overlay-get directive 'mevedel-id)
               (mevedel--directive-text directive))
      ;; Set up callback to process next directive
      (let ((callback (lambda (err fsm)
                        (if err
                            (progn
                              ;; Restore original setting and stop processing
                              (setq mevedel-auto-apply-patches original-auto-apply)
                              (message "Stopped processing at directive %d/%d due to error: %s"
                                       current total err))
                          ;; Success - continue with next directive
                          (mevedel--process-directives-sequentially
                           remaining (1+ current) total original-auto-apply)))))
        (overlay-put directive 'mevedel-directive-action 'implement)
        (mevedel--process-directive directive 'mevedel-implement
                                    #'mevedel--implement-directive-prompt callback)))))

(defvar-local mevedel--current-directive-uuid nil
  "UUID of the directive currently being processed.")

(defun mevedel--setup-org-heading-for-directive (mevedel-uuid truncated-summary header-postfix)
  "Setup or reuse org heading for directive with MEVEDEL-UUID.

MEVEDEL-UUID is the directive's unique identifier.
TRUNCATED-SUMMARY is the first line summary of the directive.

If a heading with matching MEVEDELUUID property exists, narrows to it
and positions at the end. Otherwise, creates a new heading with the
property set."
  (if-let* ((matched-headings
             (let (matches)
               (org-map-entries
                (lambda ()
                  (when (equal (org-entry-get (point) "MEVEDELUUID")
                               mevedel-uuid)
                    (push (point) matches)))
                nil nil 'archive)
               matches)))
      ;; Found existing heading with this UUID - reuse it
      (let ((target-pos (car matched-headings)))
        (goto-char target-pos)
        (org-set-tags header-postfix)
        (org-narrow-to-subtree)
        (goto-char (point-max))
        ;; Clean up trailing whitespace after prompt prefix
        (when-let* ((prefix (alist-get major-mode gptel-prompt-prefix-alist)))
          (save-excursion
            (goto-char (point-max))
            (skip-chars-backward " \t\r\n")
            (delete-region (point) (point-max))
            (insert " ")))
        (unless (bolp)
          (insert "\n")))
    ;; No existing heading - create new one
    (goto-char (point-max))
    (let ((buffer-empty-p (= (point-min) (point-max))))
      ;; Insert heading with UUID property
      (insert (concat (unless buffer-empty-p "\n\n")
                      "* " truncated-summary header-postfix "\n"))
      ;; Set the UUID property
      (save-excursion
        (forward-line -1)
        (org-set-property "MEVEDELUUID" mevedel-uuid))
      ;; Insert prompt prefix if buffer was empty
      (when buffer-empty-p
        (when-let* ((prefix (alist-get major-mode gptel-prompt-prefix-alist)))
          (insert prefix)))
      ;; Navigate to end of subtree for response
      (org-end-of-subtree)
      (unless (bolp)
        (insert "\n")))))

(defun mevedel--process-directive (directive preset prompt-fn callback)
  "Process DIRECTIVE using PRESET and PROMPT-FN, calling CALLBACK when complete.

DIRECTIVE is the instruction overlay to process.
PRESET is the gptel preset to use (mevedel-implement, mevedel-revise,
mevedel-discuss).
PROMPT-FN is a function that generates the prompt from the directive
content.
CALLBACK is called with (err fsm) when processing completes.

Updates directive status and overlay, handles success/failure states."
  ;; Save any unsaved buffers first
  (save-some-buffers nil (lambda () (and (buffer-file-name) (buffer-modified-p))))

  (let* ((directive-text (mevedel--directive-text directive))
         (content (mevedel--directive-llm-prompt directive))
         (prompt (funcall prompt-fn content))
         ;; Get chat buffer for the directive's buffer workspace
         (workspace (with-current-buffer (overlay-buffer directive)
                      (mevedel-workspace)))
         (chat-buffer (mevedel--chat-buffer t workspace))
         (callback-fn (lambda (err fsm)
                        (if err
                            (let ((reason (if (eq err 'abort) "aborted" (format "%s" err))))
                              (overlay-put directive 'mevedel-directive-status 'failed)
                              (overlay-put directive 'mevedel-directive-fail-reason reason)
                              (mevedel--update-instruction-overlay directive t)
                              (pulse-momentary-highlight-region (overlay-start directive) (overlay-end directive))
                              (setq mevedel--current-directive-uuid nil)
                              (when callback
                                (funcall callback err fsm)))

                          (overlay-put directive 'mevedel-directive-status 'succeeded)
                          (with-current-buffer (overlay-buffer directive)
                            ;; Delete any child directives of the top-level directive
                            (let ((child-directives (cl-remove-if-not #'mevedel--directivep
                                                                      (mevedel--child-instructions directive))))
                              (dolist (child-directive child-directives)
                                (mevedel--delete-instruction child-directive)))
                            (save-excursion
                              (goto-char (overlay-start directive))
                              (overlay-put directive 'evaporate t)))
                          (mevedel--update-instruction-overlay directive t)
                          (pulse-momentary-highlight-region (overlay-start directive) (overlay-end directive))
                          (setq mevedel--current-directive-uuid nil)
                          (when callback
                            (funcall callback err fsm))))))

    (with-current-buffer chat-buffer
      (setq mevedel--current-directive-uuid (overlay-get directive 'mevedel-uuid)))

    (overlay-put directive 'mevedel-directive-status 'processing)
    (mevedel--update-instruction-overlay directive t)
    (pulse-momentary-highlight-region (overlay-start directive) (overlay-end directive))

    ;; Display chat buffer if configured
    (when mevedel-show-chat-buffer
      (display-buffer chat-buffer))

    ;; Execute with gptel-request
    (with-current-buffer chat-buffer
      (let* ((prompt prompt)
             (summary directive-text)
             (action (overlay-get directive 'mevedel-directive-action))
             (action-str (symbol-name action))
             (mevedel-uuid mevedel--current-directive-uuid)
             (header-prefix "")
             (header-postfix
              ;; Add the action as a tag at the end of the headline.
              (format " :%s:" action-str))
             ;; Extract the first non-whitespace line from the summary and
             ;; truncate to fill-column.
             (truncated-summary
              (let* ((lines (split-string summary "\n" t "[[:space:]]*"))
                     (first-line (or (car lines) ""))
                     ;; Calculate available space: total fill-column minus prefix, action, and spacing.
                     (prefix (or (alist-get major-mode gptel-prompt-prefix-alist) ""))
                     (used-length (+ (length prefix) (length header-prefix) (length header-postfix)))
                     (available-length (max 10 (- (or fill-column 70) used-length))))
                (truncate-string-to-width first-line available-length nil nil "...")))
             ;; Make the separation between prompt/response clearer using a
             ;; foldable block in org-mode
             (full-prompt-str
              (concat
               (format ":PROMPT:\n" truncated-summary)
               (org-escape-code-in-string prompt)
               "\n:END:\n")))

        ;; In org-mode, manage headings with UUID tracking
        (if (and (derived-mode-p 'org-mode) mevedel-uuid)
            (mevedel--setup-org-heading-for-directive
             mevedel-uuid truncated-summary header-postfix)
          ;; Non-org-mode or no UUID: use simple insertion
          (goto-char (point-max))
          ;; If the buffer is empty, insert the prefix first.
          (when (and (= (point-min) (point-max)) (alist-get major-mode gptel-prompt-prefix-alist))
            (insert (alist-get major-mode gptel-prompt-prefix-alist))))
        ;; Header string.
        (insert (format "%s%s\n" header-prefix truncated-summary))
        ;; Add the demarcated prompt text.
        (insert full-prompt-str)
        ;; Fold the prompt immediately.
        (ignore-errors
          (save-excursion
            (search-backward ":PROMPT:")
            (when (looking-at "^:PROMPT:")
              (org-cycle)))))

      (gptel-with-preset preset
        (let* ((request-callback
                (lambda (exit-code fsm)
                  (let* ((state (gptel-fsm-state fsm))
                         (error
                          (cond
                           ;; If we have a non-nil exit code (i.e. 'abort), just
                           ;; use it as the error.
                           (exit-code)
                           ;; If the FSM is in an errored state, extract the
                           ;; error text.
                           ((eq state 'ERRS)
                            (let* ((info (gptel-fsm-info fsm))
                                   (error (plist-get info :error))
                                   (http-msg (plist-get info :status))
                                   (error-type (plist-get error :type))
                                   (error-msg (plist-get error :message)))
                              (or error-msg (format "%s: %s" error-type http-msg))))
                           ;; Otherwise, consider the request successful
                           (t
                            nil))))

                    ;; Call overlay callback, including the original callback if
                    ;; provided
                    (when (functionp callback-fn)
                      (funcall callback-fn error fsm)))))
               (fsm (gptel-request prompt
                      :buffer chat-buffer
                      ;; NOTE 2025-11-03: This seems not to be necessary?
                      ;; :position (point-max)
                      :stream gptel-stream
                      :transforms gptel-prompt-transform-functions
                      :fsm (gptel-make-fsm :handlers gptel-send--handlers)))
               ;; Extract the actual gptel callback for handling responses. By
               ;; default this will generally be `gptel--insert-response' or
               ;; `gptel-curl--stream-insert-response'.
               (info (gptel-fsm-info fsm))
               (fsm-callback (plist-get info :callback))
               (wrapped-callback
                (lambda (response &rest rest)
                  "Invoke the user-provided callback after the request is aborted.
Intercept tool results for patch capture. Then pass arguments through to
the original callback."
                  (when (eq response 'abort)
                    (funcall request-callback 'abort fsm))
                  ;; Always pass through to original callback for normal display
                  (apply fsm-callback response rest))))
          (setf (gptel-fsm-info fsm) (plist-put info :callback wrapped-callback))
          (setf (gptel-fsm-info fsm) (plist-put info :mevedel-request-callback request-callback))
          fsm)))))

(defun mevedel-abort (&optional buf)
  "Abort any active request associated with buffer BUF.

Thus, abort `gptel' requests running in the mevedel chat buffer
associated with the `mevedel-workspace' for BUF.

If a callback was provided to the original request, it will be called
with the 'abort symbol as the error parameter.

BUF defaults to the current buffer if not specified."
  (interactive)
  (with-current-buffer (or buf (current-buffer))
    (when-let* ((chat-buffer (mevedel--chat-buffer))
                (_ (buffer-live-p chat-buffer)))
      (gptel-abort chat-buffer))))

;;;###autoload
(defun mevedel-instruction-count ()
  "Return the number of instructions currently loaded instructions.

If called interactively, it messages the number of instructions and
buffers."
  (interactive)
  (let ((count 0)
        (buffer-hash (make-hash-table :test 'eq)))
    (mevedel--foreach-instruction instr count instr into instr-count
                                  do (puthash (overlay-buffer instr) t buffer-hash)
                                  finally (setf count instr-count))
    (let ((buffers (hash-table-count buffer-hash)))
      (when (called-interactively-p 'interactive)
        (if (= count 0)
            (message "No macher instructions currently loaded")
          (message "macher is showing %d instruction%s from %d buffer%s"
                   count (if (/= count 1) "s" "")
                   buffers (if (/= buffers 1) "s" ""))))
      count)))

;;;###autoload
(defun mevedel-create-reference ()
  "Create a reference instruction within the selected region.

If a region is selected but partially covers an existing reference, then
the command will resize the reference in the following manner:

  - If the mark is located INSIDE the reference (i.e., the point is
    located OUTSIDE the reference) then the reference will be expanded
    to the point.
  - If the mark is located OUTSIDE the reference (i.e., the point is
    located INSIDE the reference) then the reference will be shrunk to
    the point."
  (interactive)
  (mevedel--create-instruction 'reference))

;;;###autoload
(defun mevedel-create-directive ()
  "Create a directive instruction within the selected region.

If a region is selected but partially covers an existing directive, then
the command will resize the directive in the following manner:

  - If the mark is located INSIDE the directive (i.e., the point is
    located OUTSIDE the directive) then the directive will be expanded
    to the point.
  - If the mark is located OUTSIDE the directive (i.e., the point is
    located INSIDE the directive) then the directive will be shrunk to
    the point."
  (interactive)
  (mevedel--create-instruction 'directive))

(defcustom mevedel-default-chat-preset 'implement
  "Default preset for the chat buffer from `mevedel' command.

Can be one of the symbols:
- \\='implement
- \\='discuss"
  :group 'mevedel
  :type '(choice
          (const :tag "Implement" implement)
          (const :tag "Discuss" discuss)))

;;;###autoload
(defun mevedel ()
  "Start a chat session in the current project."
  (interactive)
  (let ((chat-buffer (mevedel--chat-buffer t)))
    (with-current-buffer chat-buffer
      (gptel--apply-preset
       (alist-get mevedel-default-chat-preset mevedel-action-preset-alist)
       (lambda (sym val) (set (make-local-variable sym) val))))))

;;;###autoload
(defun mevedel-teach ()
  "Start a teaching chat session in the current project."
  (interactive)
  (let ((chat-buffer (mevedel--chat-buffer t)))
    (with-current-buffer chat-buffer
      (gptel--apply-preset 'mevedel-teach
       (lambda (sym val) (set (make-local-variable sym) val))))))


;;
;;; Installation

;;;###autoload
(defun mevedel-install ()
  "Register `mevedel' presets, tools, and hooks."
  (interactive)

  ;; Define custom tools
  (mevedel--define-read-tools)
  (mevedel--define-edit-tools)

  ;; Define gptel presets
  (mevedel--define-presets)

  ;; Add @ref expansion to gptel transform functions and let it run early
  (add-hook 'gptel-prompt-transform-functions #'mevedel--transform-expand-refs -90)

  ;; Setup font-lock and completion for @ref mentions in gptel buffers
  (add-hook 'gptel-mode-hook #'mevedel--prettify-ref-mentions)

  (message "mevedel installed successfully"))

;;;###autoload
(defun mevedel-uninstall ()
  "Remove `mevedel' hooks and cleanup."
  (interactive)
  ;; Remove tools
  (setf (alist-get "mevedel" gptel--known-tools nil 'remove #'equal) nil)
  ;; Remove presets
  (dolist (preset '(mevedel-discuss mevedel-implement mevedel-revise))
    (setf (alist-get preset gptel--known-presets nil 'remove) nil))

  ;; Remove @ref expansion from gptel
  (remove-hook 'gptel-prompt-transform-functions #'mevedel--transform-expand-refs)

  ;; Remove font-lock and completion setup
  (remove-hook 'gptel-mode-hook #'mevedel--prettify-ref-mentions)

  (message "mevedel uninstalled successfully"))

(provide 'mevedel)

;;; mevedel.el ends here.
