#+title: Todo

* TODO [0/1] README
- [ ] Better demo videos

* TODO Add safety checks in tool functions
similar to
#+begin_src elisp
(when (not regex)
  (cl-return-from 'mevedel-tools--grep
    (funcall callback "regex parameter is required.")))
#+end_src

* TODO @ file reference in chat

* TODO Ask tool should always include preselect options (2-3 + custom)
- Also it should support multiple questions and answers

* TODO Reference navigation based on a tag query

* TODO Tag autocompletion when writing directive tag query

* Notes
** Deepseek error:
~DeepSeek error: ((HTTP/2 400) invalid_request_error) Messages with role 'tool' must be a response to a preceding message with 'tool_calls'~

  Debugger entered--Lisp error: (wrong-type-argument number-or-marker-p "[237, 270]")
  1-("[237, 270]")
  (setq start-line (1- start-line))
  (if (and (not start-line) (not end-line)) (if (> (file-attribute-size (file-attributes filename)) (* 512 1024)) (throw '--cl-block-\'mevedel-tools--read-file-lines-- (funcall callback "Error: File is too large (> 512 KB).\nPlease specify a line range to read")) (let ((temp-buffer (generate-new-buffer " *temp*" t))) (save-current-buffer (set-buffer temp-buffer) (unwind-protect (progn (insert-file-contents filename) (funcall callback (buffer-string))) (and (buffer-name temp-buffer) (kill-buffer temp-buffer)))))) (setq start-line (1- start-line)) (let* ((file-size (nth 7 (file-attributes filename))) (chunk-size (min file-size (* 512 1024))) (byte-offset 0) (line-offset (- end-line start-line))) (let ((temp-buffer (generate-new-buffer " *temp*" t))) (save-current-buffer (set-buffer temp-buffer) (unwind-protect (progn (while (and ... ...) (insert-file-contents filename nil byte-offset ...) (setq byte-offset ...) (setq start-line ...) (if ... ...)) (delete-region (point-min) (point)) (catch '--cl-block-nil-- (while ... ... ... ...)) (funcall callback (buffer-string))) (and (buffer-name temp-buffer) (kill-buffer temp-buffer)))))))
  (progn (if (file-readable-p filename) nil (throw '--cl-block-\'mevedel-tools--read-file-lines-- (funcall callback (format "Error: File %s is not readable" filename)))) (if (file-directory-p filename) (progn (throw '--cl-block-\'mevedel-tools--read-file-lines-- (funcall callback (format "Error: Cannot read directory %s as file" filename))))) (if (file-symlink-p filename) (progn (setq filename (file-truename filename)))) (let* ((full-path (expand-file-name filename)) (file-root (mevedel--file-in-allowed-roots-p full-path))) (if file-root nil (let* ((requested-root (or (file-name-directory full-path) full-path)) (reason (format "Need to read file: %s" filename)) (granted (mevedel-tools--request-access requested-root reason))) (if granted nil (throw '--cl-block-\'mevedel-tools--read-file-lines-- (funcall callback (format "Error: Access denied to %s. Cannot read file %s" requested-root filename))))))) (if (and (not start-line) (not end-line)) (if (> (file-attribute-size (file-attributes filename)) (* 512 1024)) (throw '--cl-block-\'mevedel-tools--read-file-lines-- (funcall callback "Error: File is too large (> 512 KB).\nPlease specify a line range to read")) (let ((temp-buffer (generate-new-buffer " *temp*" t))) (save-current-buffer (set-buffer temp-buffer) (unwind-protect (progn (insert-file-contents filename) (funcall callback ...)) (and (buffer-name temp-buffer) (kill-buffer temp-buffer)))))) (setq start-line (1- start-line)) (let* ((file-size (nth 7 (file-attributes filename))) (chunk-size (min file-size (* 512 1024))) (byte-offset 0) (line-offset (- end-line start-line))) (let ((temp-buffer (generate-new-buffer " *temp*" t))) (save-current-buffer (set-buffer temp-buffer) (unwind-protect (progn (while ... ... ... ... ...) (delete-region ... ...) (catch ... ...) (funcall callback ...)) (and (buffer-name temp-buffer) (kill-buffer temp-buffer))))))))
  mevedel-tools--read-file-lines(#f(compiled-function (result) #<bytecode -0x3bd248312d72c3e>) "/home/roland/Projekte/snt_dashboard/app/view/panel_3.R" "[237, 270]" nil)
  apply(mevedel-tools--read-file-lines #f(compiled-function (result) #<bytecode -0x3bd248312d72c3e>) ("/home/roland/Projekte/snt_dashboard/app/view/panel_3.R" "[237, 270]" nil))
  #f(compiled-function (tool-call) #<bytecode 0x8a06238e2174f31>)((:id "toolu_01Eqv1Wbz9e2KGKSVyoS1sEo" :name "Read" :input nil :args (:file_path "/home/roland/Projekte/snt_dashboard/app/view/panel_3.R" :start_line "[237, 270]")))
  gptel--handle-tool-use(#s(gptel-fsm :state TOOL :table ... :handlers ... :info ...))
  #f(compiled-function (h) #<bytecode 0x100be1267628c66b>)(gptel--handle-tool-use)
  gptel--fsm-transition(#s(gptel-fsm :state TOOL :table ... :handlers ... :info ...))
  gptel-curl--stream-cleanup(#<process gptel-curl> "finished\n")

  Debugger entered--Lisp error: (wrong-type-argument json-value-p ";;; mevedel-tools.el -- Tool definitions -*- lexical-binding: t -*-\n\n;;; Commentary:\n\n;;; Code:\n\n(eval-when-compile\n  (require 'cl-lib))\n\n;; `cl-extra'\n(declare-function cl-some \"cl-extra\" (cl-pred cl-seq &rest cl-rest))\n\n;; `diff-mode'\n(declare-function diff-beginning-of-hunk \"diff-mode\" (&optional try-harder))\n(declare-function diff-filename-drop-dir \"diff-mode\" (file))\n(declare-function diff-hunk-file-names \"diff-mode\" (&optional old))\n(declare-function diff-hunk-next \"diff-mode\" (&optional count))\n(declare-function diff-setup-buffer-type \"diff-mode\" ())\n\n;; `gptel-agent-tools'\n(declare-function gptel-agent--fontify-block \"ext:gptel-agent-tools\" (path-or-mode start end))\n(declare-function gptel-agent--block-bg \"ext:gptel-agent-tools\" ())\n\n;; `gptel'\n(defvar gptel--fsm-last)\n(defvar gptel--header-line-info)\n(defvar gptel-mode)\n(defvar gptel-use-header-line)\n\n;; `gptel-request'\n(declare-function gptel-make-tool \"ext:gptel-request\" (&rest slots))\n(declare-function gptel-fsm-info \"ext:gptel-request\" (cl-x) t)\n\n;; `imenu'\n(declare-function imenu--make-index-alist \"imenu\" (&optional noerror))\n(defvar imenu--index-alist)\n\n;; `mevedel'\n(defvar mevedel--diff-preview-buffer-name)\n\n;; `mevedel-diff-apply'\n(declare-function mevedel-diff-apply-buffer \"mevedel-diff-apply\" ())\n\n;; `mevedel-utilities'\n(declare-function mevedel-ediff-patch \"mevedel-utilities\" ())\n\n;; `mevedel-workspace'\n(declare-function mevedel-workspace \"mevedel-workspace\" (&optional buffer))\n(declare-function mevedel-workspace--root \"mevedel-workspace\" (workspace))\n(declare-function mevedel-workspace--file-in-allowed-roots-p \"mevedel-workspace\" (file &optional buffer))\n(declare-function mevedel-add-project-root \"mevedel-workspace\" (directory))\n(defvar mevedel-workspace-additional-roots)\n\n;; `org-src'\n(declare-function org-escape-code-in-region \"org-src\" (beg end))\n\n;; `treesit'\n(declare-function treesit-node-at \"treesit\" (pos &optional parser-or-lang named))\n(declare-function treesit-node-field-name \"treesit\" (node))\n(declare-function treesit-node-text \"treesit\" (node &optional no-property))\n\n;; `xref'\n(declare-function xref-backend-references \"xref\" (backend identifier))\n(declare-function xref-item-location \"xref\" (cl-x) t)\n(declare-function xref-item-summary \"xref\" (cl-x) t)\n\n\n;;\n;;; Parameter validation utilities\n\n(defmacro mevedel-tools--validate-params (callback function-name &rest param-specs)\n  \"Validate parameters for tool functions.\n\nCALLBACK is the callback function to call with error messages (can be\nnil for sync functions).\nFUNCTION-NAME is the name of the function being validated (symbol, can\nbe nil for lambdas).\nPARAM-SPECS is a list of (VAR TYPE-SPEC) or (VAR TYPE-SPEC REQUIRED)\nforms where:\n\n  - VAR is the parameter variable name (symbol)\n  - TYPE-SPEC is either:\n    - A predicate function symbol (e.g., stringp, integerp)\n      Special: booleanp handles both t and :json-false automatically\n    - A cons (PRED . TYPE-NAME) for custom type names\n      e.g., (vectorp . \\\"array\\\") checks with vectorp, reports \\\"array\\\"\n    - A lambda for custom validation\n      e.g., (lambda (x) (and (numberp x) (> x 0)))\n    - A cons (LAMBDA . TYPE-NAME) for lambda with custom name\n  - REQUIRED is optional, defaults to t. If nil, skip validation when\n    VAR is nil.\n\nExamples:\n  (mevedel-tools--validate-params callback my-func\n    (name stringp)                    ; Required string\n    (enabled booleanp)                ; Boolean (handles :json-false)\n    (count integerp nil)              ; Optional integer\n    (items (vectorp . \\\"array\\\"))       ; Vector reported as \\\"array\\\"\n    (score (lambda (x) (and (numberp x) (>= x 0) (<= x 100))))\n    (id ((lambda (x) (stringp x)) . \\\"non-empty string\\\")))\n\nReturns validation code that u...")
  gptel-curl--get-args((:token "375f447869a20e81810e5cca0f2d1232" :transformer #f(compiled-function (str) #<bytecode -0x489a4953c6f4b8e>) :callback gptel-curl--stream-insert-response :history ... :data ... :buffer #<buffer *mevedel:project@mevedel*> :position #<marker at 439 in *mevedel:project@mevedel*> ...) "7a43310e5d48226e5f066219e3ad2594")
  gptel-curl-get-response(#s(gptel-fsm :state WAIT :table ... :handlers ... :info ...))
  gptel--handle-wait(#s(gptel-fsm :state WAIT :table ... :handlers ... :info ...))
  #f(compiled-function (h) #<bytecode 0x10044dfa0c88c66b>)(gptel--handle-wait)
  gptel--fsm-transition(#s(gptel-fsm :state WAIT :table ... :handlers ... :info ...))
  #f(compiled-function (result) #<bytecode -0x731ae2bbc0c0fd3>)(";;; mevedel-tools.el -- Tool definitions -*- lexical-binding: t -*-\n\n;;; Commentary:\n\n;;; Code:\n\n(eval-when-compile\n  (require 'cl-lib))\n\n;; `cl-extra'\n(declare-function cl-some \"cl-extra\" (cl-pred cl-seq &rest cl-rest))\n\n;; `diff-mode'\n(declare-function diff-beginning-of-hunk \"diff-mode\" (&optional try-harder))\n(declare-function diff-filename-drop-dir \"diff-mode\" (file))\n(declare-function diff-hunk-file-names \"diff-mode\" (&optional old))\n(declare-function diff-hunk-next \"diff-mode\" (&optional count))\n(declare-function diff-setup-buffer-type \"diff-mode\" ())\n\n;; `gptel-agent-tools'\n(declare-function gptel-agent--fontify-block \"ext:gptel-agent-tools\" (path-or-mode start end))\n(declare-function gptel-agent--block-bg \"ext:gptel-agent-tools\" ())\n\n;; `gptel'\n(defvar gptel--fsm-last)\n(defvar gptel--header-line-info)\n(defvar gptel-mode)\n(defvar gptel-use-header-line)\n\n;; `gptel-request'\n(declare-function gptel-make-tool \"ext:gptel-request\" (&rest slots))\n(declare-function gptel-fsm-info \"ext:gptel-request\" (cl-x) t)\n\n;; `imenu'\n(declare-function imenu--make-index-alist \"imenu\" (&optional noerror))\n(defvar imenu--index-alist)\n\n;; `mevedel'\n(defvar mevedel--diff-preview-buffer-name)\n\n;; `mevedel-diff-apply'\n(declare-function mevedel-diff-apply-buffer \"mevedel-diff-apply\" ())\n\n;; `mevedel-utilities'\n(declare-function mevedel-ediff-patch \"mevedel-utilities\" ())\n\n;; `mevedel-workspace'\n(declare-function mevedel-workspace \"mevedel-workspace\" (&optional buffer))\n(declare-function mevedel-workspace--root \"mevedel-workspace\" (workspace))\n(declare-function mevedel-workspace--file-in-allowed-roots-p \"mevedel-workspace\" (file &optional buffer))\n(declare-function mevedel-add-project-root \"mevedel-workspace\" (directory))\n(defvar mevedel-workspace-additional-roots)\n\n;; `org-src'\n(declare-function org-escape-code-in-region \"org-src\" (beg end))\n\n;; `treesit'\n(declare-function treesit-node-at \"treesit\" (pos &optional parser-or-lang named))\n(declare-function treesit-node-field-name \"treesit\" (node))\n(declare-function treesit-node-text \"treesit\" (node &optional no-property))\n\n;; `xref'\n(declare-function xref-backend-references \"xref\" (backend identifier))\n(declare-function xref-item-location \"xref\" (cl-x) t)\n(declare-function xref-item-summary \"xref\" (cl-x) t)\n\n\n;;\n;;; Parameter validation utilities\n\n(defmacro mevedel-tools--validate-params (callback function-name &rest param-specs)\n  \"Validate parameters for tool functions.\n\nCALLBACK is the callback function to call with error messages (can be\nnil for sync functions).\nFUNCTION-NAME is the name of the function being validated (symbol, can\nbe nil for lambdas).\nPARAM-SPECS is a list of (VAR TYPE-SPEC) or (VAR TYPE-SPEC REQUIRED)\nforms where:\n\n  - VAR is the parameter variable name (symbol)\n  - TYPE-SPEC is either:\n    - A predicate function symbol (e.g., stringp, integerp)\n      Special: booleanp handles both t and :json-false automatically\n    - A cons (PRED . TYPE-NAME) for custom type names\n      e.g., (vectorp . \\\"array\\\") checks with vectorp, reports \\\"array\\\"\n    - A lambda for custom validation\n      e.g., (lambda (x) (and (numberp x) (> x 0)))\n    - A cons (LAMBDA . TYPE-NAME) for lambda with custom name\n  - REQUIRED is optional, defaults to t. If nil, skip validation when\n    VAR is nil.\n\nExamples:\n  (mevedel-tools--validate-params callback my-func\n    (name stringp)                    ; Required string\n    (enabled booleanp)                ; Boolean (handles :json-false)\n    (count integerp nil)              ; Optional integer\n    (items (vectorp . \\\"array\\\"))       ; Vector reported as \\\"array\\\"\n    (score (lambda (x) (and (numberp x) (>= x 0) (<= x 100))))\n    (id ((lambda (x) (stringp x)) . \\\"non-empt...")
  mevedel-tools--read-file-lines(#f(compiled-function (result) #<bytecode -0x731ae2bbc0c0fd3>) "/home/roland/Projekte/mevedel/mevedel-tools.el" 1 2000)
  apply(mevedel-tools--read-file-lines #f(compiled-function (result) #<bytecode -0x731ae2bbc0c0fd3>) ("/home/roland/Projekte/mevedel/mevedel-tools.el" 1 2000))
  #f(compiled-function (tool-call) #<bytecode -0x1cf2636f88d3fae5>)((:id "call_6595392306234f9a8d9371ca" :name "Read" :args (:file_path "/home/roland/Projekte/mevedel/mevedel-tools.el" :start_line 1 :end_line 2000) :result ";;; mevedel-tools.el -- Tool definitions -*- lexical-binding: t -*-\n\n;;; Commentary:\n\n;;; Code:\n\n(eval-when-compile\n  (require 'cl-lib))\n\n;; `cl-extra'\n(declare-function cl-some \"cl-extra\" (cl-pred cl-seq &rest cl-rest))\n\n;; `diff-mode'\n(declare-function diff-beginning-of-hunk \"diff-mode\" (&optional try-harder))\n(declare-function diff-filename-drop-dir \"diff-mode\" (file))\n(declare-function diff-hunk-file-names \"diff-mode\" (&optional old))\n(declare-function diff-hunk-next \"diff-mode\" (&optional count))\n(declare-function diff-setup-buffer-type \"diff-mode\" ())\n\n;; `gptel-agent-tools'\n(declare-function gptel-agent--fontify-block \"ext:gptel-agent-tools\" (path-or-mode start end))\n(declare-function gptel-agent--block-bg \"ext:gptel-agent-tools\" ())\n\n;; `gptel'\n(defvar gptel--fsm-last)\n(defvar gptel--header-line-info)\n(defvar gptel-mode)\n(defvar gptel-use-header-line)\n\n;; `gptel-request'\n(declare-function gptel-make-tool \"ext:gptel-request\" (&rest slots))\n(declare-function gptel-fsm-info \"ext:gptel-request\" (cl-x) t)\n\n;; `imenu'\n(declare-function imenu--make-index-alist \"imenu\" (&optional noerror))\n(defvar imenu--index-alist)\n\n;; `mevedel'\n(defvar mevedel--diff-preview-buffer-name)\n\n;; `mevedel-diff-apply'\n(declare-function mevedel-diff-apply-buffer \"mevedel-diff-apply\" ())\n\n;; `mevedel-utilities'\n(declare-function mevedel-ediff-patch \"mevedel-utilities\" ())\n\n;; `mevedel-workspace'\n(declare-function mevedel-workspace \"mevedel-workspace\" (&optional buffer))\n(declare-function mevedel-workspace--root \"mevedel-workspace\" (workspace))\n(declare-function mevedel-workspace--file-in-allowed-roots-p \"mevedel-workspace\" (file &optional buffer))\n(declare-function mevedel-add-project-root \"mevedel-workspace\" (directory))\n(defvar mevedel-workspace-additional-roots)\n\n;; `org-src'\n(declare-function org-escape-code-in-region \"org-src\" (beg end))\n\n;; `treesit'\n(declare-function treesit-node-at \"treesit\" (pos &optional parser-or-lang named))\n(declare-function treesit-node-field-name \"treesit\" (node))\n(declare-function treesit-node-text \"treesit\" (node &optional no-property))\n\n;; `xref'\n(declare-function xref-backend-references \"xref\" (backend identifier))\n(declare-function xref-item-location \"xref\" (cl-x) t)\n(declare-function xref-item-summary \"xref\" (cl-x) t)\n\n\n;;\n;;; Parameter validation utilities\n\n(defmacro mevedel-tools--validate-params (callback function-name &rest param-specs)\n  \"Validate parameters for tool functions.\n\nCALLBACK is the callback function to call with error messages (can be\nnil for sync functions).\nFUNCTION-NAME is the name of the function being validated (symbol, can\nbe nil for lambdas).\nPARAM-SPECS is a list of (VAR TYPE-SPEC) or (VAR TYPE-SPEC REQUIRED)\nforms where:\n\n  - VAR is the parameter variable name (symbol)\n  - TYPE-SPEC is either:\n    - A predicate function symbol (e.g., stringp, integerp)\n      Special: booleanp handles both t and :json-false automatically\n    - A cons (PRED . TYPE-NAME) for custom type names\n      e.g., (vectorp . \\\"array\\\") checks with vectorp, reports \\\"array\\\"\n    - A lambda for custom validation\n      e.g., (lambda (x) (and (numberp x) (> x 0)))\n    - A cons (LAMBDA . TYPE-NAME) for lambda with custom name\n  - REQUIRED is optional, defaults to t. If nil, skip validation when\n    VAR is nil.\n\nExamples:\n  (mevedel-tools--validate-params callback my-func\n    (name stringp)                    ; Required string\n    (enabled booleanp)                ; Boolean (handles :json-false)\n    (count integerp nil)              ; Optional integer\n    (items (vectorp . \\\"array\\\"))       ; Vector reported as \\\"array\\\"\n    (score (lambda (x) (and (numberp x) (>= x 0) (<= x 100))))\n    (id ((lambda (x) (stringp x)) . \\\"non-e..."))
  gptel--handle-tool-use(#s(gptel-fsm :state WAIT :table ... :handlers ... :info ...))
  #f(compiled-function (h) #<bytecode 0x10044dfa0c88c66b>)(gptel--handle-tool-use)
  gptel--fsm-transition(#s(gptel-fsm :state WAIT :table ... :handlers ... :info ...))
  gptel-curl--stream-cleanup(#<process gptel-curl> "finished\n")
